package main

import "fmt"

/*Важно помнить:
defer выполняется в обратном порядке
аргументы defer вычисяются при выполнении defer, но фактический вызов откладывается*/

func endPrint() {
	defer fmt.Println("Привет, это будет выведено в конце!")
	fmt.Println("Привет, это будет выведено сначала!")
}
func main() {
	defer endPrint()
	somestring := "Пять"

	defer func(x string) {
		fmt.Println(x)
	}(somestring)

	somestring = "Десять"

}

/*Это происходит из-за того, что в момент объявления отложенной анонимной функции значение переменной somestring уже было определено и somestring := "Пять".
Когда анонимная функция была отложена для выполнения, она захватила значение somestring на момент ее объявления, а не на момент ее выполнения.

Таким образом, даже если значение переменной somestring было изменено на "Десять" после того, как была отложена анонимная функция,
это не повлияет на значение, которое она выводит, поскольку она уже захватила значение "Пять" на момент своего объявления.*/
